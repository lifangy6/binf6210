---
title: "BINF*6210 Assignment 1"
subtitle: 'Fangyi Li (1092229)'
output: html_document
secondary author: Lishita Rowjee
---

# 1. Introduction
This section introduces the goal of the analysis: to test whether Canid BINs (Barcode Index Numbers) found at higher latitudes have larger geographic ranges, following Rapoport’s rule. It also reminds you to set the working directory so all files can be read and written correctly.


# 2. Package Setup
This block installs and loads all required R packages (readr, dplyr, tidyr, and ggplot2). These packages handle reading data, cleaning and summarizing tables, and creating plots. Running this ensures that the code will work even on a new computer or environment without prior setup.
```{r setup, message=FALSE, warning=FALSE}
if (!requireNamespace("readr", quietly = TRUE)) {
  install.packages("readr")
}
library(readr)

if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}
library(dplyr)

if (!requireNamespace("tidyr", quietly = TRUE)) {
  install.packages("tidyr")
}
library(tidyr)

if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}
library(ggplot2)
```

**Package setup possible improvement** 
Instead of using
if (!requireNamespace()) install.packages() four times,you can potentially use lapply() to loop through your package names.
```{r}
packages <- c("readr", "dplyr", "tidyr", "ggplot2")

invisible(lapply(packages, function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) install.packages(pkg)
  library(pkg, character.only = TRUE)
}))
```


# 3. Import BOLD Dataset
Here, the raw BOLD dataset (Canidae_BOLD.tsv) is imported using read_tsv(). This file contains all downloaded Canid barcode records, including both complete and incomplete entries. The following cleaning step will refine this dataset by removing missing or invalid coordinates to prepare it for geographic analysis.
```{r import_raw, message=FALSE, warning=FALSE}
df_raw <- readr::read_tsv(file = '../data/Canidae_BOLD.tsv')
```

**Steps before cleaning coordinates data**

(a) Before cleaning up df_raw, it would be nice to visualize the different column names present in the data set rather than scrolling through the view option.
```{r, message=FALSE, warning= FALSE}
colnames(df_raw)
```

By running the above code, we can determine that coordinates data is written in the "coord" column in the data set.Then we can visualize the first 10 values of the "coord"column to see the format in which the coordinates data is presented before deciding to clean the coordinates data. 
```{r, message=FALSE, warning=FALSE}
head (df_raw$coord)
```

(b) Additionally, using the code below, we can remove rows that are not required for analysis from the data set. 

```{r, message =FALSE, warning = FALSE}

df_raw <-df_raw [, -c(3:7, 9:21, 24:47, 51:54, 56:94 )]
colnames(df_raw)
```

(c) Cleaning coordinate data

This code filters out records without coordinates, removes the square brackets from coordinate strings, separates them into numeric latitude and longitude columns, and excludes any rows with invalid or missing values:
- 2319 records are removed because of lack of coordinates information. 
- 1258 records left.
The result is saved as Canidae_clean_coords.tsv, ensuring a reproducible and fully cleaned dataset that contains only usable geographic data.

```{r clean, message=FALSE, warning=FALSE}
df_clean <- df_raw %>%
  filter(!is.na(coord) & coord != "")

df_clean_split <- df_clean %>%
  filter(!is.na(coord) & coord != "") %>%
  mutate(coord = gsub("\\[|\\]", "", coord)) %>%   # remove [ and ]
  separate(coord, into = c("lat", "lon"), sep = ", ", remove = FALSE) %>%
  mutate(lat = as.numeric(lat), lon = as.numeric(lon)) %>%
  filter(!is.na(lat) & !is.na(lon))

readr::write_tsv(df_clean_split, "../data/Canidae_clean_coords.tsv")
```

After cleaning, the processed dataset is reloaded as df_canidae for further analysis. This confirms that the data are ready to summarize, visualize, and test without re-running the cleaning steps every time.
```{r import_clean, message=FALSE, warning=FALSE}
df_canidae <- readr::read_tsv(file = "../data/Canidae_clean_coords.tsv")

```



# 4. Summarize by BIN
This section aggregates all specimen records by their BIN identifier. For each BIN, it calculates the number of records, minimum and maximum latitude, latitudinal range (lat_max - lat_min), and the median latitude (representing where the BIN is typically found). It also records the first species name associated with each BIN. Then, it filters out BINs with missing identifiers or fewer than three records, keeping only well-sampled groups suitable for analysis.
```{r summarize_bin, message=FALSE, warning=FALSE}
bin_summary <- df_canidae %>%
  dplyr::group_by(bin_uri) %>%
  dplyr::summarise(n_records = dplyr::n(),
                   lat_min = min(lat),
                   lat_max = max(lat),
                   lat_range = lat_max - lat_min,
                   lat_median = median(lat),
                   species = dplyr::first(species)) %>%
  dplyr::ungroup()

bin_filtered <- dplyr::filter(bin_summary, !is.na(bin_uri), n_records >= 3)
bin_filtered


```

**Possible improvement to code chunk above in #4. Summarize by BIN** 
We can use the below code chunk to:
- remove BINs with missing IDs earlier in the code chunk and avoids NA groups. 
na.rm =TRUE is used in summaries for robustness
- order BINs by record count for easier interpretation

```{r, message=TRUE, warning=TRUE}
bin_summary <- df_canidae %>%
  filter(!is.na(bin_uri) & bin_uri != "") %>%   # remove missing BINs ahead
  group_by(bin_uri) %>%
  summarise(
    n_records = n(),
    lat_min = min(lat, na.rm = TRUE),
    lat_max = max(lat, na.rm = TRUE),
    lat_range = lat_max - lat_min,
    lat_median = median(lat, na.rm = TRUE),
    species_list = paste(unique(na.omit(species)), collapse = "; ") # handle multiple species
  ) %>%
  ungroup() %>%
  filter(n_records >= 3) %>% # keep only well-sampled BINs
  arrange(desc(n_records))  # can sort by sample size

print(bin_summary)
```


# 5. Distribution of Median Latitudes
This part creates a histogram showing where the BINs are most common along the latitude gradient. Most Canid BINs occur between 30° and 45° North, which means the dataset is strongly biased toward temperate northern regions, with only one or two BINs appearing in the Southern Hemisphere. This step provides context for interpreting later results.
```{r median_lat_dist, message=FALSE, warning=FALSE}
ggplot(bin_filtered, aes(x = lat_median)) +
  geom_histogram(binwidth = 10, fill = "steelblue", color = "white") +
  labs(title = "Distribution of Median Latitudes (Canidae BINs)",
       x = "Median Latitude (°)", 
       y = "Number of BINs")
```
If using proposed code chunk in section #4, the code for ggplot will change as there would be no bin_filtered data frame. Therefore code that would need to be run to obtain histogram is:

```{r median_lat_dist, message=FALSE, warning=FALSE}
ggplot(bin_summary, aes(x = lat_median)) +
  geom_histogram(binwidth = 10, fill = "steelblue", color = "white") +
  labs(title = "Distribution of Median Latitudes (Canidae BINs)",
       x = "Median Latitude (°)", 
       y = "Number of BINs")
```

# 6. Plot Latitude vs. Range Size
This section visualizes the main relationship of interest. It plots each BIN’s median latitude on the x-axis and its latitudinal range on the y-axis, coloring points by hemisphere. A linear regression line is added to highlight the trend. The resulting figure shows that the slope is slightly negative rather than positive, suggesting that higher-latitude BINs in this dataset do not have broader ranges as Rapoport’s rule predicts.
```{r linear_reg, message=FALSE, warning=FALSE}
bin_filtered <- dplyr::mutate(bin_filtered, hemisphere = ifelse(lat_median >= 0, "Northern", "Southern"))

ggplot2::ggplot(bin_filtered, ggplot2::aes(x = lat_median, y = lat_range, color = hemisphere)) +
  ggplot2::geom_point(size = 3, alpha = 0.8) +
  ggplot2::geom_smooth(method = "lm", color = "black", se = TRUE) +
  ggplot2::labs(title = "Latitudinal Range vs. Median Latitude in Canidae",
                x = "Median Latitude (°; negative = South, positive = North)",
                y = "Latitudinal Range (°)",
                color = "Hemisphere") +
  ggplot2::theme_minimal()

```



# 7. Statistical Test
Here, a linear model is fitted (lat_range ~ lat_median) to formally test whether latitude significantly predicts range size. The model summary provides the slope, standard error, p-value, and R². Assuming a 5% significance level, the result (p>0.05) shows a weak negative slope that is not statistically significant, meaning that the data do not support the expected positive relationship between latitude and geographic range size.
```{r stats, message=FALSE, warning=FALSE}
model <- lm(lat_range ~ lat_median, data = bin_filtered)
summary(model)

```

# 8. Conclusion
The cleaned Canidae dataset contained only eight BINs after filtering, and the analysis found no significant relationship between latitude and range size. This result likely reflects limited sample size and strong northern bias rather than a true absence of the Rapoport pattern. Despite the lack of statistical support, the analysis successfully demonstrates the workflow of importing, cleaning, summarizing, visualizing, and testing real biodiversity data in R.
